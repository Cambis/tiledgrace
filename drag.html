<!DOCTYPE html>
<html>
 <head>
     <meta charset="UTF-8">
     <title>Gratch</title>
     <style type="text/css">
        #codearea {
           width: 500px;
           height: 500px;
           background: #ddd;
           position: relative;
           float: left;
           overflow: auto;
        }
        .tile.operator {
           background: #9b9;
           border: 2px outset #060;
        }
        .tile.comparison-operator {
           background: #44d;
           border: 2px outset #00b;
        }
        .tile.request {
            background: #b99;
            border: 2px outset #600;
        }
        .tile.number {
           background: #8c8;
           border: 2px outset #080;
        }
        .tile.string {
           background: #cec;
           border: 2px outset #0c0;
        }
        .tile.string input {
            color: #080;
        }
        .tile.if {
           background: #88c;
           border: 2px outset #008;
           flex-direction: column;
           align-items: flex-start;
        }
        .tile.print {
           background: #cc8;
           border: 2px outset #880;
        }
        .tile {
           padding: 1px;
           width: auto;
           height: auto;
           display: inline-flex;
           float: left;
           position: absolute;
           white-space: nowrap;
           align-items: center;
           transition: opacity 0.5s;
        }
        .tile input {
           border: none;
        }
        .tile input[type=text] {
            font-family: monospace;
        }
        .selected {
           z-index: 999;
           opacity: 0.5;
           cursor: default;
        }
        .hole {
           min-width: 2em;
           padding: 1px;
           background: #aaa;
           display: inline-flex;
           width: auto;
           min-height: 12px;
        }
        #toolbox {
            background: #ccf;
            float:left;
            height: 500px;
            width: 150px;
        }
        #toolbox .tile {
            position: static;
            clear: both;
        }
        .tile .op, .tile .cmpop {
            display:inline-flex;
            padding-left: 4px;
            padding-right: 4px;
            font-weight: bold;
        }
        #gracecode {
            float: left;
            width: 200px;
            height: 500px;
        }
        .tile.bottom-join-target {
            border-bottom-color: yellow;
            border-bottom-style: solid;
        }
        .hole.multi {
           flex-direction: column;
           align-items: flex-start;
           display: flex;
        }
     </style>
 </head>
 <body>
     <div id="codearea">
     </div>
     <div id="toolbox">
         <div class="tile operator"><div class="hole number"></div><div class="op">+</div><div class="hole number"></div></div>
         <div class="tile comparison-operator"><div class="hole number"></div><div class="cmpop">==</div><div class="hole number"></div></div>
         <div class="tile number"><input type="text" value="0" size="3" ></div>
         <div class="tile string">"<input type="text" value="Hello, world!" size="13" >"</div>
         <div class="tile request"><div class="hole"></div><span style="display:inline-flex;">.</span><input type="text" size="5"></div>
         <div class="tile if"><div style="display: inline-flex; align-items: center;"><span style="display: inline-flex;">if (</span><div class="hole"></div><span style="display:inline-flex;">) then {</span></div><div style="padding-left: 2ex;"><div class="hole multi"></div></div><div><span style="display:inline;">}</span></div></div>
         <div class="tile if else"><div style="display: inline-flex; align-items: center;"><span style="display: inline-flex;">if (</span><div class="hole"></div><span style="display:inline-flex;">) then {</span></div><div style="padding-left: 2ex;"><div class="hole multi"></div></div><div><span style="display:inline;">} else {</span></div><div style="padding-left: 2ex;"><div class="hole multi"></div></div><div><span>}</span></div></div>
         <div class="tile print"><span style="margin-right: 4px;">print </span><div class="hole"></div></div>
     </div>
     <textarea id="gracecode"></textarea>
     <script type="text/javascript">
        var holes = document.getElementsByClassName('hole');
        var codearea = document.getElementById('codearea');
        var toolbox = document.getElementById('toolbox');
        var tiles = codearea.getElementsByClassName('tile');
        function findOffsetTopLeft(el) {
            var x = el.offsetLeft;
            var y = el.offsetTop;
            if (el.offsetParent && el.offsetParent != codearea && el.offsetParent != toolbox) {
                var xy = findOffsetTopLeft(el.offsetParent);
                x = x + xy.left;
                y = y + xy.top;
            }
            return {left: x, top: y};
        }
        function isBottomTarget(ch, obj) {
            if (ch.parentElement.classList.contains('hole')) {
                if (!ch.parentElement.classList.contains('multi')) {
                    return false;
                }
            }
            var chXY = findOffsetTopLeft(ch);
            var objXY = findOffsetTopLeft(obj);
            var t = chXY.top + ch.offsetHeight;
            var l = chXY.left;
            var r = chXY.left + ch.offsetWidth;
            var m = objXY.left + obj.offsetWidth / 2;
            if (objXY.top < t + 4 && objXY.top > t - 4) {
                if (m >= l && m <= r)
                    return true;
            }
            return false;
        }
        function dragstart(ev) {
            var xy = findOffsetTopLeft(this);
            var offsetY = ev.clientY - xy.top;
            var offsetX = ev.clientX - xy.left;
            var obj = this;
            ev.preventDefault();
            var dragcontinue = function(ev2) {
                var top = (ev2.clientY - offsetY);
                var left = (ev2.clientX - offsetX);
                obj.style.top = top + 'px';
                obj.style.left = left + 'px';
                ev2.preventDefault();
                var holeSize = 1000000;
                var bestHole = null;
                for (var i=holes.length - 1; i>=0; i--) {
                    var h = holes[i];
                    h.style.background = '';
                    if (h.offsetParent == obj)
                        continue;
                    var xy = findOffsetTopLeft(h);
                    xy.top = xy.top + codearea.offsetTop;
                    xy.left = xy.left + codearea.offsetLeft;
                    if (left + offsetX < xy.left
                            || left + offsetX > xy.left + h.offsetWidth) {
                        continue;
                    }
                    if (top + offsetY < xy.top
                            || top + offsetY > xy.top + h.offsetHeight) {
                        continue;
                    }
                    if (h.offsetWidth * h.offsetHeight < holeSize) {
                        holeSize = h.offsetWidth * h.offsetHeight;
                        bestHole = h;
                    }
                }
                if (bestHole != null && bestHole.children.length == 0) {
                    bestHole.style.background = 'yellow';
                }
                var tmp = obj;
                while (typeof tmp.next != "undefined" && tmp.next) {
                    var last = tmp;
                    tmp = tmp.next;
                    tmp.style.top = (last.offsetTop + last.offsetHeight) + 'px';
                    tmp.style.left = last.offsetLeft + 'px';
                }
                for (var i=0; i<tiles.length; i++) {
                    var ch = tiles[i];
                    if (ch == obj)
                        continue;
                    if (isBottomTarget(ch, obj)) {
                        ch.classList.add('bottom-join-target');
                    } else {
                        ch.classList.remove('bottom-join-target');
                    }
                }
            }
            var d = document.getElementById('codearea');
            this.style.position = 'absolute';
            this.style.top = xy.top + 'px';
            this.style.left = xy.left + 'px';
            var tmp = this;
            var runningTop = xy.top;
            while (tmp) {
                tmp.parentNode.removeChild(tmp);
                d.appendChild(tmp);
                tmp.style.position = 'absolute';
                tmp.style.top = runningTop + 'px';
                tmp.style.left = xy.left + 'px';
                runningTop += tmp.offsetHeight;
                tmp = tmp.next;
            }
            var dragend = function(ev) {
                var top = (ev.clientY - offsetY);
                var left = (ev.clientX - offsetX);
                obj.style.top = top + 'px';
                obj.style.left = left + 'px';
                d.removeEventListener('mousemove', dragcontinue);
                d.removeEventListener('mouseup', dragend);
                obj.classList.remove('selected');
                var tmp = obj;
                while (typeof tmp.next != "undefined" && tmp.next) {
                    tmp = tmp.next;
                    tmp.classList.remove('selected');
                }
                var holeSize = 1000000;
                var bestHole = null;
                for (var i=holes.length - 1; i>=0; i--) {
                    var h = holes[i];
                    if (h.offsetParent == obj)
                        continue;
                    var xy = findOffsetTopLeft(h);
                    xy.top = xy.top + codearea.offsetTop;
                    xy.left = xy.left + codearea.offsetLeft;
                    if (left + offsetX < xy.left
                            || left + offsetX > xy.left + h.offsetWidth) {
                        continue;
                    }
                    if (top + offsetY < xy.top
                            || top + offsetY > xy.top + h.offsetHeight) {
                        continue;
                    }
                    if (h.offsetWidth * h.offsetHeight < holeSize) {
                        holeSize = h.offsetWidth * h.offsetHeight;
                        bestHole = h;
                    }
                }
                if (bestHole != null) {
                    if (bestHole.children.length == 0) {
                        var tmp = obj;
                        while (tmp) {
                            tmp.style.top = 0;
                            tmp.style.left = 0;
                            tmp.style.position = 'static';
                            bestHole.appendChild(tmp);
                            tmp = tmp.next;
                        }
                        bestHole.style.background = '';
                    } else {
                        bestHole = null;
                    }
                }
                for (var i=0; i<tiles.length; i++) {
                    var ch = tiles[i];
                    ch.classList.remove('bottom-join-target');
                    if (bestHole)
                        continue;
                    if (ch == obj)
                        continue;
                    var t = ch.offsetTop + ch.offsetHeight;
                    if (isBottomTarget(ch, obj)) {
                        if (ch.next) {
                            var tmp = obj;
                            while (tmp.next)
                                tmp = tmp.next;
                            tmp.next = ch.next;
                            ch.next.prev = tmp;
                        }
                        ch.next = obj;
                        obj.prev = ch;
                        var pe = ch.parentElement;
                        var tmp = ch;
                        while (tmp.next) {
                            var last = tmp;
                            tmp = tmp.next;
                            tmp.parentElement.removeChild(tmp);
                            pe.appendChild(tmp);
                            if (pe.classList.contains('multi')) {
                                tmp.style.position = "static";
                                tmp.style.left = "";
                                tmp.style.top = "";
                            }
                            tmp.style.top = (last.offsetTop + last.offsetHeight) + 'px';
                            tmp.style.left = last.offsetLeft + 'px';
                        }
                        break;
                    }
                }
                generateCode();
            }
            d.addEventListener('mousemove', dragcontinue)
            d.addEventListener('mouseup', dragend)
            this.classList.add('selected');
            var tmp = this;
            while (typeof tmp.next != "undefined" && tmp.next) {
                tmp = tmp.next;
                tmp.classList.add('selected');
            }
            if (typeof this.prev != "undefined" && this.prev) {
                this.prev.next = false;
                this.prev = false;
            }
            ev.stopPropagation();
        }
        var blockIndent = 0;
        function generateNodeCode(n) {
            if (typeof n == 'undefined' || typeof n == 'boolean')
                return '!ABSENT!';
            if (n.classList.contains('number')) {
                return n.getElementsByTagName('input')[0].value;
            }
            if (n.classList.contains('string')) {
                return '"' + n.getElementsByTagName('input')[0].value + '"';
            }
            if (n.classList.contains('print')) {
                var arg = n.children[1].children[0];
                if (!arg)
                    return 'print(!ABSENT!)'
                if (arg.classList.contains('string')) {
                    return 'print ' + generateNodeCode(arg);
                } else if (arg.classList.contains('operator')) {
                    return 'print' + generateNodeCode(arg);
                } else {
                    return 'print(' + generateNodeCode(arg) + ')';
                }
            }
            if (n.classList.contains('request')) {
                return generateNodeCode(n.children[0].children[0]) + '.' + n.children[2].value;
            }
            if (n.classList.contains('operator') || n.classList.contains('comparison-operator')) {
                var l = false;
                var r = false;
                var op = '';
                for (var i=0; i<n.children.length; i++) {
                    var c = n.children[i];
                    if (c.classList.contains('hole')) {
                        if (l) {
                            r = c.children[0];
                            break;
                        } else {
                            l = c.children[0];
                        }
                    }
                    if (c.classList.contains('op') || c.classList.contains('cmpop')) {
                        op = c.childNodes[0].data;
                    }
                }
                return '(' + generateNodeCode(l) + ' ' + op + ' ' + generateNodeCode(r) + ')';
            }
            if (n.classList.contains('if')) {
                var cond = n.children[0].children[1].children[0];
                var bodyHole = n.children[1].children[0];
                var body = '';
                var indent = '';
                for (var i=0; i<blockIndent; i++)
                    indent += '    ';
                blockIndent++;
                for (var i=0; i<bodyHole.children.length; i++) {
                    var ch = bodyHole.children[i];
                    body = body + indent + '    ' + generateNodeCode(ch) + '\n'
                }
                var elseText = false;
                if (n.classList.contains('else')) {
                    elseText = ' else {\n';
                    var elseHole = n.children[3].children[0];
                    for (var i=0; i<elseHole.children.length; i++) {
                        var ch = elseHole.children[i];
                        elseText = elseText + indent + '    ' + generateNodeCode(ch) + '\n'
                    }
                    elseText = elseText + indent + '}'
                }
                blockIndent--;
                if (!elseText)
                    elseText = '';
                return 'if (' + generateNodeCode(cond) + ') then {\n' + body + indent + '}' + elseText;
            }
        }
        function generateCode() {
            var tb = document.getElementById('gracecode');
            tb.value = '';
            for (var i=0; i<codearea.children.length; i++) {
                var child = codearea.children[i];
                if (child.prev != false)
                    continue;
                while (child) {
                    tb.value = tb.value + generateNodeCode(child) + '\n';
                    child = child.next;
                }
            }
        }
        function attachTileBehaviour(n) {
            n.addEventListener('mousedown', dragstart);
            n.next = false;
            n.prev = false;
            Array.prototype.forEach.call(n.getElementsByTagName('input'),
                    function(el) {
                        el.addEventListener('mousedown', function(ev) {
                            ev.stopPropagation();
                        });
                        el.addEventListener('keyup', function(ev) {
                            this.size = this.value.length + 1;
                            generateCode();
                        });
                        el.addEventListener('blur', function(ev) {
                            this.size = this.value.length;
                            generateCode();
                        });
                    });
            Array.prototype.forEach.call(n.getElementsByClassName('op'),
                    function(el) {
                        el.addEventListener('dblclick', function(ev) {
                            switch(this.innerHTML) {
                                case "*":
                                    this.innerHTML = '-';
                                    break;
                                case "-":
                                    this.innerHTML = '/';
                                    break;
                                case "/":
                                    this.innerHTML = '++';
                                    break;
                                case "++":
                                    this.innerHTML = '+';
                                    break;
                                default:
                                    this.innerHTML = '*';
                            }
                            generateCode();
                        });
                    });
            Array.prototype.forEach.call(n.getElementsByClassName('cmpop'),
                    function(el) {
                        el.addEventListener('dblclick', function(ev) {
                            switch(this.innerHTML) {
                                case "==":
                                    this.innerHTML = '<';
                                    break;
                                case "<":
                                    this.innerHTML = '>';
                                    break;
                                default:
                                    this.innerHTML = '==';
                            }
                            generateCode();
                        });
                    });
        }
        function attachHoleBehaviour(n) {
            n.addEventListener('mouseup', holedrop);
            n.addEventListener('mousemove', function(){alert("entering");});
        }
        function attachToolboxBehaviour(n) {
            n.addEventListener('mousedown', function(ev) {
                var cl = this.cloneNode();
                codearea.appendChild(cl);
                cl.style.position = 'absolute';
                cl.style.top = (this.offsetTop - toolbox.offsetTop) + 'px';
                cl.style.left = '500px';
                attachTileBehaviour(cl);
                dragstart.call(cl, ev);
            });
        }
        Array.prototype.forEach.call(codearea.getElementsByClassName('tile'),
                attachTileBehaviour);
        Array.prototype.forEach.call(toolbox.getElementsByClassName('tile'),
                attachToolboxBehaviour);
     </script>
 </body>
</html>
